<html lang="en">
<head>
	<title>Video Kaleidoscope</title>
	<meta content="Threejs, WebGl, shaders,  js, creative coding, generative art, genart" name="keywords">
	<meta content="Video Kaleidoscope made with Threejs shaders " name="description">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<meta property="og:image" content="http://jlchapa.azurewebsites.net/img/kaleidoscopeSquare.png" />

	<style>
		body {
			background-color: #000;
			color: #FFF;
			margin: 0px;
			overflow: hidden;
		}

		#container{
			margin: 0 auto;
		}
		p{
			position: absolute;
			bottom: 0;
			left: 0;
		}
	</style>
</head>
<body>

	<video id="monitor" autoplay width="640" height="480"  style=" display:none"></video>
	<canvas id="videoImage" width="640" height="480" style=" display:none"></canvas>
	<div id="container"></div>

	<script src="../js/build/three.min.js"></script>
	<script src="../js/build/TrackballControls.js"></script>
	<script src="../js/jquery-2.1.3.min.js"></script>
	<script src="../js/randomColor.js"></script>
	<script src="shaders/EffectComposer.js"></script>
	<script src="shaders/RenderPass.js"></script>
	<script src="shaders/ShaderPass.js"></script>
	<script src="shaders/MaskPass.js"></script> 
	<script src="shaders/CopyShader.js"></script>
	<script src="shaders/KaleidoShader.js"></script>
	<script src="shaders/RGBShiftShader.js"></script>

	<script>

	/*The idea is to create a new and unique kaleidoscope from a video source, 

	Then we add the shader pass, one for the rgb and another one for the kaleidoscope effect, their parameters like number of sides and angles are also randomized.
	*/

	var container, camera, scene, renderer, controls;
	var kaleidoParams, kaleidoPass, rgbParams, rgbPass, composer;


	var video, videoImage, videoImageContext, videoTexture;

	navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia;
	window.URL = window.URL || window.webkitURL;

	function streaming(stream) 
	{
		video.src = window.URL.createObjectURL(stream);
		video.onerror = function(e) {   stream.stop();   };
		stream.onended = noStreaming;
	}

	function noStreaming(e) 
	{
		console.log("Error with camera");
	}

	function init() {

		video = document.getElementById('monitor');
		videoImage = document.getElementById( 'videoImage' );
		videoImageContext = videoImage.getContext( '2d' );

		navigator.getUserMedia({video: true}, streaming, noStreaming);

		scene = new THREE.Scene();
		camera = new THREE.PerspectiveCamera(55, 1, 20, 1000);
		camera.position.set(0,0,100);
		camera.lookAt(new THREE.Vector3(0,0,0));

		var ambient = new THREE.AmbientLight(0x888888);
		scene.add(ambient);

		videoTexture = new THREE.Texture( videoImage );
		videoTexture.minFilter = THREE.LinearFilter;
		videoTexture.magFilter = THREE.LinearFilter;

		var movieMaterial = new THREE.MeshBasicMaterial( { map: videoTexture, overdraw: true, side:THREE.DoubleSide } );

		var geometry = new THREE.PlaneGeometry( 100, 100 );
		var material = new THREE.MeshBasicMaterial ( {color: 0xffff00, side: THREE.DoubleSide}) ;
		var plane = new THREE.Mesh( geometry, movieMaterial );
		scene.add( plane );

		renderer = new THREE.WebGLRenderer({alpha:true});
		renderer.setClearColor( 0xffffff, 0);
		renderer.setSize( window.innerWidth, window.innerHeight );
		$("#container").append(renderer.domElement);

		//POST PROCESSING
		var renderPass = new THREE.RenderPass( scene, camera );
		rgbPass = new THREE.ShaderPass( THREE.RGBShiftShader );
		kaleidoPass = new THREE.ShaderPass( THREE.KaleidoShader );

		//Add Shader Passes to Composer
		composer = new THREE.EffectComposer( renderer);
		composer.addPass( renderPass );
		composer.addPass( kaleidoPass );
		composer.addPass( rgbPass );
		//since the rgb pass is the last we set it to renderToScreen
		rgbPass.renderToScreen = true;

		rgbPass.uniforms[ "angle" ].value = 0;
		rgbPass.uniforms[ "amount" ].value = 0.01;
		kaleidoPass.uniforms[ "sides" ].value = 7;

		createControls();
		window.addEventListener('resize', onWindowResize, false);
	}

	function animate() {
		if ( video.readyState === video.HAVE_ENOUGH_DATA ) {
			videoImageContext.drawImage( video, 0, 0 );
			if ( videoTexture ){
				videoTexture.needsUpdate = true;
			} 
		}

		var t = Math.sin(Date.now()/1000) / 5000;
		rgbPass.uniforms[ "angle" ].value += 0.01;
		rgbPass.uniforms[ "amount" ].value += t;
		composer.render(0.1);
		controls.update();
		requestAnimationFrame( animate );
	}

	function createControls(){
		controls = new THREE.TrackballControls(camera, renderer.domElement);
	}

	function onWindowResize() {
		camera.aspect = 1;
		camera.updateProjectionMatrix();
		renderer.setSize(window.innerWidth, window.innerHeight);
	}

	init();
	animate();


</script>

<script src="../js/ga.js"></script>

</body></html>