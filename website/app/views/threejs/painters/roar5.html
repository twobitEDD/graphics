<!DOCTYPE html>
<html>
<head>
  <title>Perlin noise - random</title>

  <style>
  body {
    background-color: #eee;
    margin: 0 auto;
    overflow: hidden;
    font-size: 14pt;
    font-family: sans-serif;
    color: #000;
  }
  #canvas{
    float:left;
    width: 50%;
    height: 100%;
  }

  #canvas2{
    float:left;
    width: 50%;
    height: 100%;
  }
  #info{
    position: absolute;
    left: 0;
    bottom: 0;
  }
  </style>
</head>

<body>

  <canvas id="canvas"></canvas>
  <canvas id="canvas2"></canvas>
  <div id="info">
    Click anywhere to restart <br/>
    Press any key pause animation
  </div>

  <script src='../js/perlin.js'></script>
  <script src='../js/randomcolor.js'></script>
  <script src='../js/jquery-2.1.3.min.js'></script>


  <script>

/*
Using noise functions to create Rorschach test like patterns
Insipred by:  https://medium.com/@mattdesl/generative-impressionism-afa98ccb97da#.q7xzdkw5n
Using code from: https://github.com/josephg/noisejs
Cool colors by: https://github.com/davidmerfield/randomColor
*/

  var canvas = document.getElementById('canvas');
  var canvas2 = document.getElementById('canvas2');
  var ctx = canvas.getContext('2d');
  var ctx2 = canvas2.getContext('2d');
  
  /*We are using the library randomColor to get an array of beautiful accent and background colors in rgb format, very convinient */
  var bgColors = randomColor({hue: "monochrome", count:10, format: "rgbArray", luminosity: 'light'});
  var colors = randomColor({count:10, format: "rgbArray"});

  var image = ctx.createImageData(canvas.width, canvas.height);
  var data = image.data;
  
  var time = 10;
  var animationTime = 0.1;

  var colorIndex = 0;
  var bgColorIndex = 0;
  var bgMaxLevel = 0.3;
  var pause = false;

  function drawFrame() {

    if(!pause){

      /*Loop through all the pixels in our image*/
      for (var x = 0; x < canvas.width; x++) {
        for (var y = 0; y < canvas.height; y++) {

          /*We want to know which color should we paint each pixel, 
          to do that we call the noise function which will return a value between -1 and 1 */
          var value = noise.perlin3(x/100 , y/100, animationTime);
          
          /*
          Remember: our image data is stored in an array, each pixel of our image needs 4 values to calculate its color
          so the lenght of our image data array will be numPixels * 4.
          To get the correspondin cell in the array given our current x,y position we use the following:
          */
          var cell = (x + y * canvas.width) * 4;

          /*Awesome, now we know the cell and the value, we just need to decide what color correspond to it*/

          if(value < bgMaxLevel){
            /*Background, all the pixels whose noise value is less than bgMaxLevel will be considered background */
            data[cell] = bgColors[bgColorIndex][0]; 
            data[cell + 1] = bgColors[bgColorIndex][1]; 
            data[cell + 2] = bgColors[bgColorIndex][2];
          }else if(value<0.35){
            /*Accent color*/
            data[cell] = colors[colorIndex][0]; 
            data[cell + 1] = colors[colorIndex][1]; 
            data[cell + 2] = colors[colorIndex][2];
          }else if(value<0.4){
            /*White*/
            data[cell] = data[cell + 1] = data[cell + 2] = 255;
          }
          else {
            /*Black*/
            data[cell] = data[cell + 1] = data[cell + 2] = 0;
          }

          /* Remember how each pixel needs 4 values to set know its color
          The first three are R,G,B the last one its the Alpha and we always set it to its maximum value (unless you want a translucid color)*/
          data[cell + 3] = 255; 
        }
      }

      /*Copy the image to the canvas*/
      ctx.putImageData(image, 0, 0);
      /*Take whatever is on the canvas and put it on our second canvas
       which has the transformation to make it look like the mirror image */ 
      ctx2.drawImage(canvas, 0, 0);
      
      time += 0.005;
      animationTime = Math.sin(time)+Math.cos(time*2);
    }

    requestAnimationFrame(drawFrame);
  }

  function restart(){

  //Give a new seed to the noise function, to get a different pattern
  noise.seed(Math.random());
  
  //Get new index to change background and accent color
  colorIndex = Math.floor(Math.random()*colors.length);
  bgColorIndex = Math.floor(Math.random()*bgColors.length);
  
  //Choose a different maximum level, all pixels whose noise value is below this level will be considered background 
  bgMaxLevel = 0.1 + Math.random()*0.3;
}

function resize(){
  canvas.width = canvas2.width = Math.floor(window.innerWidth/2);
  canvas.height = window.innerHeight;
  canvas2.height = window.innerHeight;

  image = ctx.createImageData(canvas.width, canvas.height);
  data = image.data;

  /*Apply a transformation to the second canvas who will act as our mirrored image*/
  ctx2.translate(canvas2.width, 0);
  ctx2.scale(-1, 1);
  
}


$("canvas").click(function(){
  restart();
});

$(window).keypress(function() {
  pause = !pause;
});

$(window).resize(function() {
  resize();
});

/*To start we first call the function resize() to set the appropiate width and height, 
then we start the animation loop*/
resize();
requestAnimationFrame(drawFrame);

</script>
</body>