<!DOCTYPE html>
<html lang="en">
<head>
	<title>Fractal Subdivision</title>
	<meta content="Automatas, canvas, js, creative coding, generative art, genart" name="keywords">
	<meta content="Semi autonomus organisms that attract their nearby neighbors. " name="description">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

	<style>
		body {
			font-family: "Open Sans", "Arial", Monospace;
			background-color: #000;
			color: #fff;
			margin: 0px;
			overflow: hidden;
		}
	</style>
	<script src="../js/build/three.min.js"></script>	
	<script src="../js/build/TrackballControls.js"></script>
	<script src="../js/jquery-2.1.3.min.js"></script>
	<script src="../js/randomColor.js"></script>
</head>

<body>
	<div id="container"></div>
	
	<script>
		var container, camera, scene, renderer, controls;
		var lines = [];
		var MAX_POINTS = 500;
		var maxMaxRad = 200;
		var minMaxRad = 100;
		var minRadFactor = 0.3;
		var circle;
		var iterations = 3;
		var TWO_PI = 2*Math.PI;
		var	windowHalfX = window.innerWidth / 2;
		var windowHalfY = window.innerHeight / 2;
		var lineNumber = 100;

		function init() {

			container = document.getElementById('container');
			scene = new THREE.Scene();
			camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 2000 );
			camera.position.y = 800;
			camera.position.z = 400;
			camera.up = new THREE.Vector3( 0, 0, 1 );
			camera.lookAt(new THREE.Vector3( 0, 0, 0 ));

			var ambient = new THREE.AmbientLight( 0x666666 );
			scene.add( ambient );

			var d = 500;
			var light = new THREE.DirectionalLight(0xdfebff, 0.8);
			light.position.set(-300, 200, 500);
			light.castShadow = true;
			light.shadowMapWidth = 512;
			light.shadowMapHeight = 512;
			light.shadowCameraLeft = -d;
			light.shadowCameraRight = d;
			light.shadowCameraTop = d;
			light.shadowCameraBottom = -d;
			light.shadowCameraFar = 1000;
			light.shadowDarkness = 0.3;
			scene.add(light);

			var light2 = new THREE.DirectionalLight(0xdfebff, 0.7);
			light2.position.set(300, 200, 500);
			light2.castShadow = true;
			//light2.shadowCameraVisible = true;
			light2.shadowMapWidth = 512;
			light2.shadowMapHeight = 512;
			light2.shadowCameraLeft = -d;
			light2.shadowCameraRight = d;
			light2.shadowCameraTop = d;
			light2.shadowCameraBottom = -d;
			light2.shadowCameraFar = 1000;
			light2.shadowDarkness = 0.5;
			scene.add(light2);


			//GROUND
			var textureSquares = THREE.ImageUtils.loadTexture( "img/bright_squares256.png" );
			textureSquares.repeat.set( 50, 50 );
			textureSquares.wrapS = textureSquares.wrapT = THREE.RepeatWrapping;
			textureSquares.magFilter = THREE.NearestFilter;
			textureSquares.format = THREE.RGBFormat;

			var groundMaterial = new THREE.MeshPhongMaterial( {
				shininess: 80,
				color: 0xff0000,
				specular: 0xffffff,
				map: textureSquares
			} );

			planeMaterial = new THREE.MeshLambertMaterial({color:  0x888888});
			plane = new THREE.Mesh(new THREE.PlaneGeometry(800, 500), groundMaterial);
			plane.material.side = THREE.DoubleSide;
			plane.receiveShadow = true;
			plane.castShadow = false;

			scene.add( plane );

			var material = new THREE.LineBasicMaterial( { color: randomColor({hue:"blue"})} );

			setCircles();
			var i, j;
			var r = 0, g=0, b=0;

			var vertices = [];
			var holes = [];
			var triangles, mesh;
			var buildingGeometry = new THREE.Geometry();
			//var buildingMaterial = new THREE.MeshLambertMaterial({ color: 0x00ffff} );
			var buildingMaterial = new THREE.MeshPhongMaterial({ color: 0x444444, metal:true, reflectivity: 0.8, } );
			var boxmaterial      = new THREE.MeshLambertMaterial();
			//var buildingMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff} );


			for(i=0; i<lineNumber; i++){
				var newPoints = calculateNewPoints();

				var geometry = new THREE.BufferGeometry();
				var size=newPoints.length * 3;
				var positions = new Float32Array( size ); /* 3 vertices per point*/
				geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
				var line = new THREE.Line( geometry,  material );
				line.position.x = -200;
				scene.add( line );

				var posArray = line.geometry.attributes.position.array;
				var index = 0;
				for (j=0; j<newPoints.length; j++){

					var x = newPoints[j][0];
					var y = newPoints[j][1];
					var z = i*3;

					posArray[ index++ ] = x;
					posArray[ index++ ] = y;
					posArray[ index++ ] = z;

					vertices.push( new THREE.Vector3(x, y, z) );

					// var sphere = new THREE.Mesh(geometryS, materialS);
					// sphere.position.x = x;
					// sphere.position.y = y;
					// sphere.position.z = z;
					// scene.add(sphere);

				}
			}


			buildingGeometry.vertices = vertices;
			var vertexIndex = 0;
			var numVertexPerLine = Math.pow(2,iterations);
			var offset = numVertexPerLine+1;
			for( var i = 0; i < lineNumber-1; i++ ){

				for( var j = 0; j < numVertexPerLine; j++ ){
					var v01 = vertexIndex;
					var v11 = offset + vertexIndex;
					vertexIndex++;
					var v02 = vertexIndex;
					var v12 = offset + vertexIndex;
					if(vertexIndex%offset == 0){
						v02 -= numVertexPerLine;
						v12 -= numVertexPerLine;
					}

					buildingGeometry.faces.push( new THREE.Face3( v01, v02, v11 ) );
					buildingGeometry.faces.push( new THREE.Face3( v02, v12, v11 ) );
				}

				vertexIndex++;

			}

			buildingGeometry.computeFaceNormals();
			buildingGeometry.computeVertexNormals();
			mesh = new THREE.Mesh( buildingGeometry, buildingMaterial );
			mesh.material.side = THREE.DoubleSide;
			mesh.position.x = 200;
			mesh.castShadow = true;
			scene.add(mesh);

			renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.shadowMapEnabled = true;
			renderer.shadowMapSoft = true;
			container.appendChild( renderer.domElement );
			controls = new THREE.TrackballControls( camera );
			window.addEventListener( 'resize', onWindowResize, false );
		}

		function onWindowResize() {
			windowHalfX = window.innerWidth / 2;
			windowHalfY = window.innerHeight / 2;
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize( window.innerWidth, window.innerHeight );
		}

		function animate() {
			requestAnimationFrame( animate );
			controls.update();
			render();
		}

		function render() {
			renderer.render( scene, camera );
		}



		function setCircles() {
			var i;
			var maxR, minR;
			var grad;

			circle = null;

			maxR = minMaxRad+Math.random()*(maxMaxRad-minMaxRad);
			minR = minRadFactor*maxR;

			var newCircle = {
				centerX: 0,
				centerY: 0,
				maxRad : maxR,
				minRad : minR,
				param : 0,
				changeSpeed : 1/lineNumber,
				phase : Math.random()*TWO_PI, /*the phase to use for a single fractal curve.*/
			};
			newCircle.pointList1 = setLinePoints(iterations);
			newCircle.pointList2 = setLinePoints(iterations);
			circle= newCircle;

		}


		function calculateNewPoints() {
			var i,c;
			var rad;
			var point1,point2;
			var x0,y0;
			var cosParam;
			var points = [];
			var yOffset;

			c = circle;
			c.param += c.changeSpeed;
			if (c.param >= 1) {
				c.param = 0;

				c.pointList1 = c.pointList2;
				c.pointList2 = setLinePoints(iterations);
			}
			cosParam = 0.5-0.5*Math.cos(Math.PI*c.param);

			point1 = c.pointList1.first;
			point2 = c.pointList2.first;
			c.phase += 0.0002;
			theta = c.phase;
			rad = c.minRad + (point1.y + cosParam*(point2.y-point1.y))*(c.maxRad - c.minRad);
			x0 = c.centerX + rad*Math.cos(theta);
			y0 = c.centerY + rad*Math.sin(theta);
			points.push([x0, y0]);

			while (point1.next != null) {
				point1 = point1.next;
				point2 = point2.next;
				theta = TWO_PI*(point1.x + cosParam*(point2.x-point1.x)) + c.phase;
				rad = c.minRad + (point1.y + cosParam*(point2.y-point1.y))*(c.maxRad - c.minRad);
				x0 = c.centerX + rad*Math.cos(theta);
				y0 = c.centerY + rad*Math.sin(theta);
				points.push([x0, y0]);
			}

			return points;
		}

		/*Here is the function that defines a noisy (but not wildly varying) data set which we will use to draw the curves.*/
		function setLinePoints(iterations) {
			var pointList = {};
			pointList.first = {x:0, y:1};
			var lastPoint = {x:1, y:1}
			var minY = 1;
			var maxY = 1;
			var point;
			var nextPoint;
			var dx, newX, newY;
			var ratio;

			var minRatio = 0.5;

			pointList.first.next = lastPoint;
			for (var i = 0; i < iterations; i++) {
				point = pointList.first;
				while (point.next != null) {
					nextPoint = point.next;

					dx = nextPoint.x - point.x;
					newX = 0.5*(point.x + nextPoint.x);
					newY = 0.5*(point.y + nextPoint.y);
					newY += dx*(Math.random()*2 - 1);

					var newPoint = {x:newX, y:newY};

					/*min, max*/
					if (newY < minY) {
						minY = newY;
					}
					else if (newY > maxY) {
						maxY = newY;
					}

					/*put between points*/
					newPoint.next = nextPoint;
					point.next = newPoint;

					point = nextPoint;
				}
			}

			/*normalize to values between 0 and 1*/
			if (maxY != minY) {
				var normalizeRate = 1/(maxY - minY);
				point = pointList.first;
				while (point != null) {
					point.y = normalizeRate*(point.y - minY);
					point = point.next;
				}
			}
			/*unlikely that max = min, but could happen if using zero iterations. In this case, set all points equal to 1.*/
			else {
				point = pointList.first;
				while (point != null) {
					point.y = 1;
					point = point.next;
				}
			}

			return pointList;		
		}

		init();
		animate();

	</script>

</body>
</html>
